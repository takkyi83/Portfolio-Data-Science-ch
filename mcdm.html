<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" charset="UTF-8">
    <title>Project Page</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<a id="top"></a>
<div style="text-align: right;"><h2><a href="https://ch.sherry-liu.com/">前往首頁</a></h2></div>
<div class="container">
    <h1>有選擇困難症？ 如何以科學的方法來決策：多準則決策（Multi-criteria decision）</h1>
    <div class="content">
        <div class="image-container">
            <img src="mcdm-banner.png" class="header-image centered-image" alt="Header Image">
        </div>
    </div>
    <p>
        你想買一隻手機，你會用什麼標準來抉擇呢？ 是只要喜歡就買？ 還是選擇最便宜的？ 還是兩個皆是？ 我們的抉擇往往很少取決於單一條件。抉擇通常要考慮多個條件、多個限制、短期影響、長期影響、影響的權重等等。不過於複雜的抉擇，例如買手機，可能有5～6個考量點，我們還可以應付。但如果是決定要把機場蓋在哪裡呢？這其中牽涉的考量點多達數十個甚至更多，中間有錯綜複雜的關係。考量點之間往往有衝突（conflicting criteria），面對這麼更複雜的選擇，這往往需要一些科學的方式來幫助我們。這裡介紹的多準則決策（Multi-criteria decision， MCDM）就是其中之一。
    </p>
    <h2>什麼是多準則決策？</h2>
    <p>
        多準則決策（Multi-criteria decision， MCDM）是指在面對多個相互競爭或衝突的準則時，做出最佳決策的過程。在這種情況下，不同的準則可能對決策結果產生不同的影響，而且這些準則可能存在不同的優先級。多準則決策旨在尋找一種有效的方法來綜合考慮這些準則，並找到最優的解決方案。
    </p>
    <p>
        多準則決策可以應用在各種不同的領域和問題中，例如企業管理、投資決策、資源分配、城市規劃、環境保護等。在這些問題中，決策者需要考慮多個相關因素和目標，並在這些因素之間進行權衡和取捨。
    </p>

    <p>
        解決多準則決策問題的方法有很多，這裡介紹一下幾種方法。

    <ul>1. 層次分析法（Analytic Hierarchy Process，AHP）：將多準則問題轉換為層次結構，然後通過對比判斷矩陣來評估不同準則之間的相對重要性，最終找到最優解。</ul>

        <ul>1. 加權總分法（Weighted Sum Method）：將每個準則的重要性進行加權，然後計算各個解決方案的加權總分，最終選擇總分最高的方案作為最佳決策。</ul>

        <ul>2.網路層級分析法（Analytic Network Process，ANP）：ANP是一種多準則決策方法，它是AHP（層次分析法）的擴展，用於解決具有循環依賴和相互作用的複雜決策問題。ANP通過建立一個具有層次結構的網路模型來評估不同準則和子準則之間的相對重要性，並最終進行權重的組合和決策的選擇。這個方法在處理複雜的多準則決策問題時很有用，特別是當準則之間存在相互依賴關係時。</ul>


        <ul>3. 簡單加權法（Simple Additive Weighting, SAW）：該方法將每個準則的重要性以權重的形式表示，並將每個選項在每個準則上的表現乘以相應的權重，然後將這些乘積相加，得到每個選項的綜合得分。最終，得分最高的選項被視為最優選擇。</ul>

    <ul>4. 使用簡單加權法（Simple Additive Weighting, SAW）進行選擇，並使用「最大標準化」（Max Standardisation）對屬性值進行標準化
    </ul>

    <ul>5. 採用「簡單加權法（Simple Additive Weighting，SAW）」與「幾何平均標準化（Geo-Mean Standardization）」</ul>

    <ul>6. 理想解相似度順序偏好法 Technique for Order Preference by Similarity to the Ideal Solution，TOPSIS)</ul>

    </p>
    <p>多準則決策是一個複雜的問題，不同的問題可能需要不同的方法和技術來解決。選擇合適的多準則決策方法需要根據具體問題的特點和需求來進行評估和選擇。
    </p>

    <h2>1. 層次分析法（Analytic Hierarchy Process，AHP）</h2>
    <p>
        層次分析法是一種用於處理多準則決策問題的系統性方法，由美國數學家和運籌學家Thomas L. Saaty於1970年提出。AHP的目標是幫助決策者在面對複雜的抉擇情況時，將不同的準則和選擇方案進行結構化、量化並進行比較，最終找到最優的決策方案。
    </p>
    <p>
        AHP的基本思想是將決策問題分解為多個層次（Hierarchy），每個層次代表一個層次的因素或準則，並且層次之間呈現父子關係。最上層是目標層，即要達成的目標或問題的整體目標。下一層是準則層，包含了實現目標所需的各個準則或因素。再下一層是選擇層，包含了不同的選擇方案。每個層次中的元素之間都存在兩兩比較的關係。
    </p>

    <p>
        AHP的優點在於能夠將複雜的決策問題進行結構化，將主觀的評價轉換為量化的數據，使決策過程更加透明和客觀。它可以幫助決策者更好地理解決策問題的層次結構和各個因素之間的相對重要性，從而做出更明智的決策。因此，AHP在許多領域，包括企業管理、工程規劃、環境評估等方面都得到廣泛應用。
    </p>

    <ul>
        1. 創建比較矩陣：首先創建一個大小為3x3的比較矩陣M，用於比較三個元素之間的相對重要性。比較矩陣是對稱矩陣，對角線元素為1，表示元素與自身的比較。
    </ul>
    <pre><code>
        # 引入gdata函式庫
        library(gdata);

        # 創建一個3x3的對角矩陣M
        M <- diag(3);

        # 對M進行賦值
        M[2,3]<-1/3;
        M[1,3]<-3;
        M[1,2]<-5;

        # 由上三角矩陣計算下三角矩陣
        lowerTriangle(M) <- 1/upperTriangle(M, byrow=TRUE);
    </code></pre>

    <ul>
        2. 正規化比較矩陣：將比較矩陣M的每列元素進行正規化處理，使每列元素之和為1，得到正規化比較矩陣MP。
    </ul>
    <pre><code>
        # 對M的每一列進行加總，結果存儲在向量V中
        V<-c(0,0,0);
        V<-colSums(M);

        # 將向量V的每個元素除以相應的列加總，得到正規化化的配對比較矩陣（normalized pairwise comparison matrix）
        MP<-matrix(0,3,3);
        MP[,1]<-M[,1]/V[1];
        MP[,2]<-M[,2]/V[2];
        MP[,3]<-M[,3]/V[3];
    </code></pre>
    <ul>
        3. 計算相對優先級：通過計算正規化比較矩陣MP的行均值，得到每個元素的相對優先級CWV。
    </ul>
    <pre><code>
        # 對MP的每一行計算平均值，得到相對優先級向量CWV
        CWV<-c(0,0,0);
        CWV<-rowMeans(MP);
    </code></pre>

    <ul>
        4. 使用幾何平均：將正規化比較矩陣MP中每行元素的幾何平均值計算得到新的相對優先級CWV2。
    </ul>
    <pre><code>
        # 使用幾何平均方法計算CWV2向量
        CWV2<-c(0,0,0);
        CWV2[1]<-(MP[1,1]*MP[1,2]*MP[1,3])^(1/3);
        CWV2[2]<-(MP[2,1]*MP[2,2]*MP[2,3])^(1/3);
        CWV2[3]<-(MP[3,1]*MP[3,2]*MP[3,3])^(1/3);
    </code></pre>
    <ul>
        5. 一致性分析：通過一致性檢定，檢查決策者對於比較矩陣的判斷是否具有一致性。一致性指標包括一致性指數（CI）和一致性比率（CR）。如果CR值小於0.1，表示判斷具有一致性，否則表示判斷缺乏一致性。<br>
        如果一致性程度可接受，則可以繼續進行決策過程。<br>
        如果一致性程度不可接受，則DM應重新考慮並可能修正配對比較判斷，然後再進行分析。
    </ul>
    <pre><code>
    # 將每一行的值相加，得到一個標記為“加權和”的向量。'%*%' 是矩陣乘法
    V <- M %*% CWV;

    # 將得到的加權和向量中的元素除以相應的優先級值。
    X<- V/CWV;

    # 計算得到的值的平均值，用Lambda_max表示。
    Lambda_Max <- mean(X);

    # 計算一致性指標（CI）
    CI <- (Lambda_Max-3)/(3-1);

    # 計算一致性比例（CR）
    CR <- CI/0.58;

    # 根據CR判斷是否接受一致性檢測
    if (CR > 0.1)
    {
      print("沒通過一致性檢定");
    }
    else
    {
      print("通過一致性檢定");
    }
    </code></pre>

    <h2>2. 層次分析法（Analytic Network Process， ANP）</h2>
    是一種多準則決策方法，用於解決複雜的決策問題，特別是在多個準則和子準則之間存在相互關聯的情況。<br>
    ANP是AHP的擴展，用於解決具有循環依賴和相互作用的多準則決策。<br>
    以下用ANP評估機場可達性（Airport Accessibility）
    <p>
        <ul>
        1. MAR (Market Attractiveness Rating)
        這部分代碼用於計算市場吸引力的評分。首先，建立一個大小為7x7的對角矩陣M，然後對矩陣中的一些元素進行設置，表示不同因素之間的相對重要性（比例對比）。接著將矩陣進行正規化，使每列的和為1，得到正規化後的矩陣MP。再計算MP的行平均值，得到市場吸引力的相對優先性向量CWV。
    <pre><code>
        ## Airport Accessibility
        library(gdata)
        #MAR
        M <- diag(7);
        M[1,2]<-1/7;
        M[1,3]<-1/3;
        M[1,4]<-1/3;
        M[1,5]<-1;
        M[1,6]<-1/7;
        M[1,7]<-1/2;
        M[2,3]<-5;
        M[2,4]<-5;
        M[2,5]<-5;
        M[2,6]<-3;
        M[2,7]<-5;
        M[3,4]<-2;
        M[3,5]<-2;
        M[3,6]<-1/5;
        M[3,7]<-3;
        M[4,5]<-3;
        M[4,6]<-1/5;
        M[4,7]<-1;
        M[5,6]<-1/5;
        M[5,7]<-2;
        M[6,7]<-5;
        lowerTriangle(M) <- 1/upperTriangle(M, byrow=TRUE);

        # Sum the columns
        V<-c(0,0,0,0,0);
        V<-colSums(M);

        # Divide the sum of the columns back to M
        MP<-matrix(0,7,7);
        MP[,1]<-M[,1]/V[1];
        MP[,2]<-M[,2]/V[2];
        MP[,3]<-M[,3]/V[3];
        MP[,4]<-M[,4]/V[4];
        MP[,5]<-M[,5]/V[5];
        MP[,6]<-M[,6]/V[6];
        MP[,7]<-M[,7]/V[7];

        # Compute the average of rows, to obtain the CWV
        CWV<-c(0,0,0,0,0,0,0);
        CWV<-rowMeans(MP);
    </code></pre>
        </ul>
    <ul>
        2. ACC (Airport Accessibility)
        這部分代碼用於計算機場可達性的評分，過程類似於MAR部分。首先建立一個大小為7x7的對角矩陣M，然後對矩陣中的一些元素進行設置，表示不同因素之間的相對重要性（比例對比）。接著將矩陣進行正規化，得到正規化後的矩陣MP。再計算MP的行平均值，得到機場可達性的相對優先性向量CWV1。
        <pre><code>
        library(gdata)
        #ACC
        M <- diag(7);
        M[1, 2]<-3
        M[1, 3]<-0.33
        M[1, 4]<-0.2
        M[1, 5]<-0.2
        M[1, 6]<-3
        M[1, 7]<-2
        M[2, 3]<-0.2
        M[2, 4]<-0.2
        M[2, 5]<-0.2
        M[2, 6]<-0.5
        M[2, 7]<-0.33
        M[3, 4]<-2
        M[3, 5]<-2
        M[3, 6]<-5
        M[3, 7]<-3
        M[4, 5]<-0.5
        M[4, 6]<-5
        M[4, 7]<-3
        M[5, 6]<-5
        M[5, 7]<-3
        M[6, 7]<-0.33
        lowerTriangle(M) <- 1/upperTriangle(M, byrow=TRUE);

        #ACC
        # Sum the columns
        V<-c(0,0,0,0,0,0,0);
        V<-colSums(M);

        # Divide the sum of the columns back to M
        MP<-matrix(0,7,7);
        MP[,1]<-M[,1]/V[1];
        MP[,2]<-M[,2]/V[2];
        MP[,3]<-M[,3]/V[3];
        MP[,4]<-M[,4]/V[4];
        MP[,5]<-M[,5]/V[5];
        MP[,6]<-M[,6]/V[6];
        MP[,7]<-M[,7]/V[7];

        # Compute the average of rows, to obtain the CWV
        CWV1<-c(0,0,0,0,0,0,0);
        CWV1<-rowMeans(MP);
        </code></pre>
    </ul>
    <ul>
        3. COS (Cost of Stay)
        這部分代碼用於計算停留成本的評分，過程類似於前兩部分。首先建立一個大小為7x7的對角矩陣COS，然後對矩陣中的一些元素進行設置，表示不同因素之間的相對重要性（比例對比）。接著將矩陣進行正規化，得到正規化後的矩陣CosMP。再計算CosMP的行平均值，得到停留成本的相對優先性向量CosCWV2。
        <pre><code>
            #COS
            COS <- diag(7)
            COS[1,2]=1/6
            COS[1,3]=1/7
            COS[1,4]=5
            COS[1,5]=1/7
            COS[1,6]=1/9
            COS[1,7]=7
            COS[2,3]=1/3
            COS[2,4]=7
            COS[2,5]=3
            COS[2,6]=1/3
            COS[2,7]=7
            COS[3,4]=7
            COS[3,5]=5
            COS[3,6]=1/2
            COS[3,7]=8
            COS[4,5]=1/8
            COS[4,6]=1/6
            COS[4,7]=3
            COS[5,6]=1/5
            COS[5,7]=9
            COS[6,7]=7
            lowerTriangle(COS) <- 1/upperTriangle(COS,byrow = T)

            #cwv
            CosV <- c(0,0,0)
            CosV <- colSums(COS)

            CosMP <- matrix(0,7,7)
            for(i in c(0:7))
            {
              CosMP[,i] <- COS[,i]/CosV[i]
            }

            CosCWV2 <- c(0,0,0)
            CosCWV2<- rowMeans(CosMP)
        </code></pre>
    </ul>
    <ul>4. CAP (Cultural Attractions Points)
        這部分代碼用於計算文化吸引力的評分，過程類似於前面幾部分。首先建立一個大小為7x7的對角矩陣M，然後對矩陣中的一些元素進行設置，表示不同因素之間的相對重要性（比例對比）。接著將矩陣進行正規化，得到正規化後的矩陣MP。再計算MP的行平均值，得到文化吸引力的相對優先性向量CWV3。
        <pre><code>
        #CAP
        M <- diag(7);
        M[1,2] = 1/2
        M[1,3] = 2
        M[1,4] = 2
        M[1,5] = 1/3
        M[1,6] = 5
        M[1,7] = 1/5
        M[2,3] = 3
        M[2,4] = 2
        M[2,5] = 1/3
        M[2,6] = 5
        M[2,7] = 4
        M[3,4] = 2
        M[3,5] = 1/5
        M[3,6] = 5
        M[3,7] = 1/7
        M[4,5] = 1/3
        M[4,6] = 5
        M[4,7] = 5
        M[5,6] = 5
        M[5,7] = 1/3
        M[6,7] = 1/9

        lowerTriangle(M) <- 1/upperTriangle(M, byrow=TRUE);

        # Sum the columns
        V<-colSums(M);

        # Divide the sum of the columns back to M
        MP<-matrix(0,7,7);
        MP[,1]<-M[,1]/V[1];
        MP[,2]<-M[,2]/V[2];
        MP[,3]<-M[,3]/V[3];
        MP[,4]<-M[,4]/V[4];
        MP[,5]<-M[,5]/V[5];
        MP[,6]<-M[,6]/V[6];
        MP[,7]<-M[,7]/V[7];

        # Compute the average of rows, to obtain the CWV
        CWV3<-c(0, 0, 0, 0, 0, 0, 0);
        CWV3<-rowMeans(MP);

        S<- diag(4);
        S[1,2] = 4
        S[1,3] = 1/2
        S[1,4] = 2
        S[2,1] = 1/4
        S[2,3] = 1/4
        S[2,4] = 1/4
        S[3,4] = 4
        lowerTriangle(S) <- 1/upperTriangle(S, byrow=TRUE);

        # Sum the columns
        V<-c(0,0,0,0);
        V<-colSums(S);

        # Divide the sum of the columns back to M
        SP<-matrix(0,4,4);
        SP[,1]<-S[,1]/V[1];
        SP[,2]<-S[,2]/V[2];
        SP[,3]<-S[,3]/V[3];
        SP[,4]<-S[,4]/V[4];

        # Compute the average of rows, to obtain the CWV
        CWV4<-c(0, 0, 0, 0);
        CWV4<-rowMeans(SP);
        </code></pre>
    </ul>

    <ul>5. 最後，將四個向量合併為一個矩陣X，並使用層次分析法（AHP）的方法來對這些評分進行綜合分析，得出最終的排序結果SI。SI是一個向量，其負值表示最終排序的結果，即越小的值表示該項目的優先性越高。最後使用rank函數對SI進行排序，以獲得最終的排序結果。
        <pre><code>
        X=rbind(CWV,CWV1,CosCWV2,CWV3)
        colnames(X)=c('A1','A2','A3','A4','A5','A6','A7')

        SI = t(X)%*%CWV4

        rank(-SI)
        </code></pre>
    </ul>
    </p>

    <h2>3. 簡單加權法（Simple Additive Weighting, SAW）</h2>
    SAW方法允許決策者根據屬性的相對重要性來分配權重，然後根據屬性值的加權和來計算每個選擇的分數，進而對選擇進行排名，幫助決策過程。
    <ul>
        1. 創建一個空的資料框「y」，用於存儲每個汽車選擇的屬性值。該資料框有4行，分別代表汽車型號（'Civic'、'Saturn'、'Ford'、'Mazda'），有3列代表屬性（'Style'、'Reliability'、'FuelEco'）。
        <pre><code>
            # Create empty data frame
            y <- data.frame(matrix(data=0, ncol = 3, nrow = 4));
            colnames(y) <- c("Style","Reliability","FuelEco");
            rownames(y) <- c("Civic","Saturn","Ford","Mazda");
            str(y);
        </code></pre>
    </ul>

    <ul>2. 使用「c()」函數，將屬性值分配給每個汽車選擇的行。每行填充了汽車型號的屬性值（Style、Reliability、FuelEco）。
        <pre><code>
            # Assign atrribute values to each alternative row
            y["Civic",] <- c(7,9,9);
            y["Saturn",] <- c(8,7,8);
            y["Ford",] <- c(9,6,8);
            y["Mazda",] <- c(6,7,8);
        </code></pre>
    </ul>

    <ul>
        3. 添加一個額外的列「SAW_score_vector」，用於存儲計算後的每個汽車選擇的SAW分數。初始值為所有選擇的分數都設為0。
        <pre><code>
            # Append a column to store the SAW-ed scores for each alternative
            SAW_score_vector <- c(0,0,0,0);
            y<-cbind(y,SAW_score_vector);
        </code></pre>
    </ul>

    <ul>4. 定義「SAW_weight_vector」，表示決策者（DM）分配給每個屬性的權重。
    <pre><code>
        SAW_weight_vector <- c(0.3,0.4,0.3);
    </code></pre>
    </ul>

    <ul>5. 通過將屬性值與權重向量相乘，計算每個汽車選擇的加權總分。計算後的分數存儲在每個汽車選擇的「SAW_score_vector」列中。
    </ul>
    <pre><code>
        SAW_weight_vector * y["Civic",];
        y["Civic","SAW_score_vector"] <- sum (SAW_weight_vector * y["Civic",]);

        SAW_weight_vector * y["Saturn",];
        y["Saturn","SAW_score_vector"] <- sum (SAW_weight_vector * y["Saturn",]);

        SAW_weight_vector * y["Ford",];
        y["Ford","SAW_score_vector"] <- sum (SAW_weight_vector * y["Ford",]);

        SAW_weight_vector * y["Mazda",];
        y["Mazda","SAW_score_vector"] <- sum (SAW_weight_vector * y["Mazda",]);
    </code></pre>

    <ul> 6.根據計算後的SAW分數，以降序方式對選擇進行排序（排名）。排名結果存儲在「SAW_rank_vector」列中。
        <pre><code>
        SAW_rank_vector <- order(-y$SAW_score_vector);
        y<-cbind(y,SAW_rank_vector);
        </code></pre>
    </ul>

    <h2>4. 使用簡單加權法（Simple Additive Weighting, SAW）進行選擇，並使用「最大標準化」（Max Standardisation）對屬性值進行標準化</h2>
    和上一個SAW例子的代碼基本相同。不同處在步驟3之前構建一個新的資料框「y_standardised」，用於存儲標準化後的屬性值。將每個屬性值除以該屬性的最大值，進行最大標準化。其餘步驟相同。<br>
    使用最大標準化可以將不同屬性的值轉換為相同的範圍，使得它們在加權計算時的影響平等，幫助確保更準確地進行決策過程。
    <pre><code>
        # Construct standardized y
        y_standardised <- y;
        y_standardised[,"Style"]<-y[,"Style"]/max(y[,"Style"]);
        y_standardised[,"Reliability"]<-y[,"Reliability"]/max(y[,"Reliability"]);
        y_standardised[,"FuelEco"]<-y[,"FuelEco"]/max(y[,"FuelEco"]);
        y<-y_standardised;
    </code></pre>

    <h2>5. 採用「簡單加權法（Simple Additive Weighting，SAW）」與「幾何平均標準化（Geo-Mean Standardization）」</h2>
    在簡單加權法的步驟3之前計算y_standardised以用幾何平均來標準化y。其他步驟相同
    <pre><code>
        # Construct standardized y
        y_standardised <- y;
        y_standardised[,"Style"]<-y[,"Style"]/sqrt(sum(y[,"Style"]^2));
        y_standardised[,"Reliability"]<-y[,"Reliability"]/sqrt(sum(y[,"Reliability"]^2));
        y_standardised[,"FuelEco"]<-y[,"FuelEco"]/sqrt(sum(y[,"FuelEco"]^2));
        y<-y_standardised;
    </code></pre>

    <h2>6. 理想解相似度順序偏好法（Technique for Order Preference by Similarity to the Ideal Solution, TOPSIS）</h2>
    是一種多屬性決策方法，用於在多個競爭方案中找到最佳選擇。它的基本理念是尋找一個理想解和一個反理想解，然後根據每個方案與這兩個極端解的相似度來進行排序。它適用於各種競爭方案的選擇和排序問題。能幫助決策者更清晰地理解和評估各個方案的優勢和劣勢，從而做出更好的選擇。需要注意的是，TOPSIS方法的結果依賴於所選擇的標準化方法和權重向量的設定，因此進行決策時需要謹慎處理這些參數。
    <ul>
        1. 創建決策矩陣：首先，將所有的競爭方案的屬性值組成一個決策矩陣，其中每一行代表一個方案，每一列代表一個屬性。
        <pre><code>
            DecisionMatrix<-matrix(0,4,4);
            DecisionMatrix[1,]<-c( 49, 81, 81, 64);
            DecisionMatrix[2,]<-c( 64, 49, 64, 49);
            DecisionMatrix[3,]<-c( 81, 36, 64, 81);
            DecisionMatrix[4,]<-c( 36, 49, 64, 36);
            DecisionMatrix;
        </code></pre>
    </ul>

    <ul>
        2. 標準化決策矩陣：對決策矩陣進行標準化，這是為了避免因為不同屬性的量值范圍差異而導致計算結果不公平。標準化的方法可以是最大-最小標準化、z-score標準化等。標準化後，每個屬性的值都落在0到1的範圍內。
        <pre><code>
            #Normalize the decision matrix according to the standard operation defined by TOPSIS
            NumRows<-nrow(DecisionMatrix);
            NumCols<-ncol(DecisionMatrix);
            D_normalize<-matrix(0,NumRows,NumCols);
            for ( j in c(1:NumCols) )
             {   D_normalize[,j]<-DecisionMatrix[,j]/sqrt(sum(DecisionMatrix[1:NumRows,j]^2))
             };

            #Setup the criterion weight vector CWV and compute the weighted (normalized) decision matrix WNDMatrix
            CWV<-c(.1,.4,.3,.2);
            WNDMatrix<-matrix(0,NumRows,NumCols);
            for ( j in c(1:NumCols))
             {   WNDMatrix[,j]<-CWV[j]*D_normalize[,j];
             };
        </code></pre>
    </ul>

    <ul>
        3.確定理想解和反理想解：在標準化後的決策矩陣中，找到理想解（A+）和反理想解（A-）。理想解是每個屬性中的最大值，而反理想解則是每個屬性中的最小值。
        <pre><code>
            # Determine the ideal A_plus and anti-ideal solution A_minus
            A_plus<-c(0,0,0,0);
            for ( j in c(1:NumCols))
             {   A_plus[j]<-max(WNDMatrix[1:NumRows,j]);
             };
            A_plus;
            # Give a special process because 4 is TLTB
            A_plus[4]<-min(WNDMatrix[1:NumRows,4]);

            A_minus<-c(0,0,0,0);
            for ( j in c(1:NumCols))
             {   A_minus[j]<-min(WNDMatrix[1:NumRows,j]);
             };
            # Give a special process because 4 is TLTB
            A_minus[4]<-max(WNDMatrix[1:NumRows,4]);
        </code></pre>
    </ul>

    <ul>
        4. 計算方案與理想解和反理想解的相似度：計算每個方案與理想解的距離（稱為S+），以及與反理想解的距離（稱為S-）。一般來說，使用歐氏距離或曼哈頓距離等來計算相似度。
        <pre><code>
        # Calculate the seperation measure for each alternative

        # Distances toward ideal solution A_plus
        S_to_ideal<-c(1:NumRows);
        for( i in c(1:NumRows) )
         {   S_to_ideal[i]<-sqrt( sum(
                                       (WNDMatrix[i,]-A_plus[])^2
                                     )
                                );
         };

        # Distances toward anti-ideal solution A_minus
        S_to_anti_ideal<-c(1:NumRows);
        for( i in c(1:NumRows) )
         {   S_to_anti_ideal[i]<-sqrt( sum(
                                           (WNDMatrix[i,]-A_minus[])^2
                                          )
                                     );
         };
        </code></pre>
    </ul>

    <ul>
        5. 計算相對接近度：使用S+和S-計算每個方案相對於理想解的相對接近度，通常用Ti的數值來表示。
        <pre><code>
            # Calculate the relative closeness (of each alternative) to the ideal solution, which is the Tie-Jin Xi-Shu
            RC<-c(1:NumRows);
            for( i in c(1:NumRows) )
             {   RC[i]<-S_to_anti_ideal[i]/(S_to_ideal[i]+S_to_anti_ideal[i]);
             }; # Equivalant to: RC<-S_to_anti_ideal/(S_to_ideal+S_to_anti_ideal)
        </code></pre>
    </ul>

    <ul>
        6. 決策方案排序：根據相對接近度Ti的值，將方案進行排序。Ti值越接近1，表示方案越接近理想解，排名越靠前。
        <pre><cpde>
            order(RC, decreasing=TRUE);
            RC[order(RC, decreasing=TRUE)];
        </cpde></pre>
    </ul>

    <h2>結論</h2>
    <p>
        在這個多準則決策方法（MCDM）的分析中，實作了三種主要方法：簡單加權法（Simple Additive Weighting, SAW）、最大標準化和幾何平均標準化。此外，還引入了理想解相似度順序偏好法（Technique for Order Preference by Similarity to the Ideal Solution, TOPSIS）作為另一種重要的多準則決策工具。
    </p>
    <p>
        在MCDM中，我們面臨著不同方案之間的競爭，並需要基於多個屬性的評估來做出最佳選擇。每種方法都有其特定的優勢和限制，因此在決策過程中，我們必須根據具體情況選擇適合的方法。
    </p>
    <p>
        簡單加權法（SAW）允許決策者根據屬性的相對重要性來分配權重，並根據加權值對方案進行排名。這種方法的優勢在於易於理解和實現，但它假設屬性的重要性是固定的，並不能很好地處理不同屬性之間的相對重要性變化。
    </p>
    <p>
        為了克服簡單加權法的限制，我們引入了最大標準化和幾何平均標準化。最大標準化將屬性值縮放到0到1的範圍，確保不同屬性值的公平比較，並消除因量值范圍差異而導致計算結果不公平的問題。幾何平均標準化進一步提供了平衡的評估方式，使得屬性的相對重要性更加均衡。
    </p>
    <p>
        此外，TOPSIS方法為多準則決策提供了另一種強大的框架。它不僅考慮了方案與理想解的距離（S+），還考慮了方案與反理想解的距離（S-）。這樣一來，我們可以更全面地評估每個方案的相對優勢和劣勢，從而更準確地進行排名和選擇。
    </p>
    <p>
        然而，需要強調的是，這些方法的效果取決於決策背景、屬性權重和標準化方法的選擇。在實際應用中，我們必須仔細考慮這些因素，以確保得出合理且可靠的結果。
    </p>
    <p>
        多準則決策方法為各個領域的複雜決策場景提供了有價值的工具。通過結合不同的方法並適應特定的決策情境，我們可以更好地理解和評估各個方案的優勢和劣勢，從而做出更明智的選擇。這些方法不僅在商業和工業領域有用，也可以應用於社會、環境和政策等各種領域，幫助我們解決現實生活中的各種複雜問題。
    </p>
</div>
<div style="text-align: right;">
    <h3><a href="https://ch.sherry-liu.com/">前往首頁</a></h3>
    <h3><a href="#top">前往頂端</a></h3>
</div>
</body>
</html>
